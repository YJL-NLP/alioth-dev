---
title: 新语法特性
date: 2019/05/09
author: GodGnidoc
encoding: utf8
lang: Chinese
---

# 概述

本文档描述`Alioth`语言在`0.9`版本中引入的新的语法特性。

[TOC]

# 约定

在Alioth各个语法结构中，都存在着对某种数据结构的接口的约定。

约定分为**名称约定**和**特性约定**.

## 名称约定

名称约定系列约定某种名称具有确定的语义。

### 字符串

`Alioth`约定类型用例`string`所指向的类总用于描述一个**字符串**。

### 字符

`Alioth`约定类型用例`char`所指向的类总用于描述一个**字符**。

### 元组

`Alioth`约定类型用例`tuple`所指向的模板类总用于描述**元组**类型。

### 执行流展开宿主

`Alioth`约定类型用例`DefUnwindHost`所指向的类是**默认执行流展开宿主**。

## 特性约定

特性约定表示，当一个类满足足够的条件时，被视为一种特定的类。

### 容器

1. 迭代器子类

   容器类应当拥有名为`iterator`和`citerator`的两个子类。

   分别满足**迭代器约定**和**受限迭代器约定**。

2. 迭代方法

   容器类应当拥有如下方法

   `begin`和`cbegin`方法返回一个起始迭代器。

   `end`和`cend`方法返回一个结束迭代器。

### 迭代器

1. 提取方法

   `method get() ref Type`

   `method const get() ref const Type`

2. 迭代方法

   `method inc () ref this class`

### 元组

1. 是模板类

   对每个模板参数都有原型存储

2. 提取运算符

   对每个模板参数都有提取运算符

   `operator # n () ref Type `

   `operator const # n () ref const Type`

# 模块签名

## 入口标记

在模块签名中添加入口标记语法支持，去除了前缀式的入口方法标记方案。

~~~
module App entry main : dep
~~~

入口方法必须是透明类中的元方法，计目的是简化词法分析器中的微型语法分析器。

## 带集合的依赖描述符

```
module Test : {io memory string}@linux
```

提供集中描述来自相同程序的依赖的语法支持。

## 带变量的依赖描述符

```
module Test : usb@"driver-$(sys)-$(cpu)"
```

在`iString`描述的程序中，可以使用`$()`引导一个编译器变量。

编译器变量存放在编译器配置文件中，其值与编译器的安装环境有关，提供了使用相同的源码适配不同平台的语法支持。

## 带通配符的依赖描述符

~~~
module Test : *@linux
~~~

通过通配符引用一个模块中所有的模块，自动去重。

# 元素类型关键

在`Alioth0.9`中修改了`VAR`和`VAL`两种元素类型的关键字和对应名称。

```
var --> obj
val --> rel
```

## OBJ

**OBJ**表示此元素与对象直接绑定。

## REL

**REL**表示此元素将重定位对象的作用域。

# 组合关键字

`Alioth0.9`引入了一系列组合关键字语法，提供了一些特化指代语法支持。

## 当前类

`this class`关键字用于表示当前类，是一个**类型用例**。

抽象类的方法的返回值被指定为**this class**，此方法就会在各个子类中被正确重载。如果方法的算法不需要改变，则手动书写这样的重载就会浪费时间。

## 当前模块

在依赖描述符中，若指定依赖模块的别名为`this module`则表示进行语法树根合并。

~~~
module App : dep as this module
~~~

## 返回对象

`return obj`组合关键字指代返回值对象，是一个元素。

此语法特性提供了在返回之前访问返回对象的语法支持，这样可以避免由返回造成的拷贝等开销。

~~~
return obj.data = read(buf);
return obj.lock = true;
return return obj;
~~~

# 执行流

`Alioth-0.9`重新敲定了关于执行流的语法规则。

## Lambda

~~~
var fun = $( arg1 Type, arg2 Type ) var Type {
	Do something...
};
~~~

使用`$()`引导**Lambda**表达式的构造。

与之前设计的语法规则类似，**Lambda**表达式可以是准，虚，可以使用可变参数包。

## Unwind

~~~
$[ TaskSet @ Host > Processor ] ( index, iterator ) {
	Do something ... 
}
~~~

* 任务集 TaskSet

  - 任务集满足**Alioth容器**约定
  - 任务集满足**Alioth元组**约定
  - 任务集是数字

* 宿主 Host

  宿主满足**执行流展开宿主**约定

* 处理器 Processor

  * 处理器可以是方法
  * 处理器也可以是Lambda表达式

* 看门狗

  剩余部分描述一个看门狗过程，看门狗过程在每个任务完成时被出发，并且一定在当前执行流被执行。

  第一个参数是执行流的索引，对于元组任务集，索引和切面对应。

  第二个参数是迭代器，若任务集是容器，可以获取当前迭代器。

## Return

~~~
${data.clear();}
~~~

返回过程用于注册一个离开此作用域时一定被执行的过程。

返回过程可以多次注册，最后会被按顺序执行。

# 前导语境

Alioth使用一些关键字可以引导一些特殊的语境，临时改变语法规则。

## 类型语境

在`Alioth`中，模板参数列表的打开`<`和运算符`<`是一样的。

`Alioth`规定仅在不可能出现关系运算符`<`的语境中将`<`分析为模板参数列表。

在表达式中，要创造这样的语境，需要使用`class`关键字来引导一个短暂的类型描述语境。

## 取引用

要对一个元素所绑定的取引用，可以使用`ref`引导一个取引用语境，简化`Obj as ref`式的语法结构。

~~~
return ref Obj;
~~~

## 取重载

要对一个元素取重载，可以使用`rel`引导一个取重载的语境，简化`Obj as rel`式的语法结构

~~~
store( rel Obj );
~~~