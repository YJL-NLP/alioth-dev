---
title: 运算符语法设计
author: GodGnidoc
date: 2019/05/07
lang: Chinese
encoding: utf8
---

# 概述

本文档描述`Alioth`编程语言`0.9`版本下的运算符重载语法，其中包括特化运算符9种，泛化运算符若干，讨论方面包括运算符的本质，运算符重载的定义语法和实现语法，以及各种运算符重载的行为特征。

[TOC]

# 1. 运算符重载

运算符重载可以产生或替换一个**运算符$_{operator}$**，赋予一种数据类型新的行为能力。

在源代码中，使用对应运算符将对象链接进入表达式则构成对运算符的调用。

运算符应当用于处理轻量级任务，所以**默认情况下，运算符被标记为<u>原子过程</u>**。

由**运算符**`op`关联的对象`a`和`b`，被称为**运算子$_{operand}$**。

根据运算规则，最先被求值参与运算的**运算子**被称为**主运算子$_{master\ operand}$**。

剩余的**运算子**若存在，则称为**从运算子$_{slave\ operand}$**。

在**简单数据类型$_{SimpleType}$**之间，根据**运算符结合性方向**选取主从运算子。

在**复合数据类型$_{CompositeType}$**与其他数据类型之间，根据从左到右的顺序寻找第一个拥有此运算符重载的对象作为主运算子。

# 2. 特化运算符

**特化运算符是类定义伴生复合数据类型默认必备的运算符。**

**定制型特化运算符未被重载之前不存在，所以类定义伴生复合数据类型默认不拥有这些运算符。**

通过一个移除签名，可以删除一个默认存在的特化运算符。

特化运算符共有九种，包括**结构化构造运算符、序列化构造运算符、析构运算符、拷贝构造运算符、移动构造运算符、类型转换运算符、成员运算符、定位运算符**和**移动运算符**。

## 2.1. 结构化构造运算符

结构化构造运算符$_{Structural\ Constructor}$提供结构化的对象构造语法支持。默认情况下，复合数据类型拥有一个不接受任何参数的结构化构造运算符，这个默认的结构化构造运算符对复合数据类型的所有成员调用默认构造运算符。

重载任何形式的结构化构造运算符都会删除默认提供的结构化构造运算符。最终，唯一一个可以不接受任何参数的结构化构造运算符被视为**默认构造运算符**。

### 2.1.1. 定义

结构化构造运算符的标签是`{}`，也可以使用`sctor`作为结构化构造运算符的标签。

~~~
operator {} ( arg1 Type, arg2 Type = Expr, arg3 Type, ... args )
operator sctor( arg1 Type = Expr, arg2 Type, arg3 Type = Expr )
~~~

### 2.1.2. 实现

结构化构造运算符的实现体是一个**构造器**，构造器描述了复合数据类型对象的每一个成员的构造规则，未被提及的成员，编译器试图调用其默认构造运算符。

构造器由三部分构成：**基类构造表达式，成员构造列表，后置构造过程**。

~~~
operator Scope::Class sctor( arg1 Type, arg2 Type, arg3 Type ) {
    {BasicTypeA| param:Expr}
    {BasicTypeB| param:Expr, param:Expr}
    
    attr : Expr, attr : Expr, attr : Expr |

    Implementation......
}
~~~

基类构造表达式被置于成员构造列表之前，没有顺序要求，若没有基类，此部分可省。

成员构造列指定一些成员的构造表达式

后置构造过程与成员构造列表之间用`|`分割，分隔符优先级次于其运算符语义。后置构造过程用于处理一些成员构造之外的事情，在所有成员都正确构造之后被执行，若不需要，此部分连同分隔符可省。

### 2.1.3. 调用

结构化构造运算符的调用通过书写**结构化构造表达式**实现。

结构化构造表达式由可选的类型描述符和传参列表构成，中间使用分隔符`|`分割。

~~~
var conn = {HttpConnection|
    Url: "http://dn-ezr.cn",
    Method: Http::GET };

var comm Comm = {
    name: "COM4",
    bandrate: 9600,
    stopbit: 1 };
~~~

结构化构造表达式的参数必须带参数名传递，因此消除了顺序的必要性，可以安排任意参数的默认参数，减小重载量。

## 2.2. 序列化构造运算符

序列化构造运算符$_{List\ Constructor}$提供用于构造序列对象的直观语法支持。序列化构造运算符是定制类特化运算符，默认情况下复合数据类型不拥有序列化构造运算符。

### 2.2.1. 定义

序列化构造运算符的标签是`[...]`，也可以使用`lctor`作为序列化构造运算符的标签。

~~~
operator [...] ( arg1 Type, ... args )
operator lctor ( arg1 Type, arg2 Type, ... args Type )
~~~

虽然序列化构造运算符的参数列表是随意定制的，但`Alioth`更鼓励开发人员提供可变参数包` ... args `。

### 2.2.2. 实现

序列化构造运算符同样是构造运算符，其运算符体同结构化构造运算符一样，也是一个构造器。

~~~
operator Scope::Class [...] ( arg1 Type, arg2 Type, ... args Type ) {
    {BasicType| param:Expr}
    attr: Expr, attr Expr |
    Implementation
}
~~~

### 2.2.3. 调用

在构造语境或表达式中，使用`[]`引导序列化构造运算符的调用。

~~~
var nameList = [class List<string>| "GodGnidoc", "lzl" ];

var conn = {HttpConnection|
	Url: "http://dn-ezr.cn",
	Method: Http:GET,
	Params: [<"Name","Ezr">,<"Action","Login">]
}
~~~

序列化构造表达式的类型标签不要求`class`关键字的引导，但是示例中的`List<string>`是带模板参数列表的类型用例，需要`class`引导一个类型用例的语境。

## 2.3. 析构运算符

析构运算符与**析构函数**没有实质性的差别，析构运算符的设计是为了和构造运算符统一风格。

### 2.3.1. 定义

析构运算符的运算符标签是`{~}`，也可以使用`dtor`作为析构运算符的标签。

~~~
operator {~}()
~~~

~~~
operator dtor()
~~~

### 2.3.2. 实现

析构运算符的运算符体是一个指令块

~~~
operator Scope::Class dtor() {

}
~~~

